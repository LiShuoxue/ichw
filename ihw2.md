# 作业2 

**停机问题提出的原因**

二十世纪，随着数学逻辑的发展与第三次数学危机的出现，图灵等人试图从逻辑上找到解决方法，故提出了停机问题。

**停机问题的证明与数学原理**

假如存在万能的程序B，而且当任意的程序A可以停机时，B做出判断以告知另外一个程序C，C便会持续运作;倘若B判断A持续运行，则C根据B的判断结果而停机。

假如以上的A程序和C程序是同一个，那么我们把所有的A代换成C，便是这一句自相矛盾的话：

>假如上述万能的B存在，而且当C可以停机时，B做出判断以告知C，C便会持续运作；倘若B判断C持续运行，则C根据B的判断结果而停机。

所以没有一种机器可判断所有程序能否会停机。

停机问题的数学本质，是1931年哥德尔所提出的“不完全性定理”，即“任何一个形式系统，只要包括了简单的初等数论描述，而且是自洽的，它必定包含某些系统内所允许的方法既不能证真也不能证伪的命题。”

**对二进制补码的科普**

同学们有没有发现，当我们打开科学计算器的二进制功能，输入“-1”时，会得到一连串的“1”。而且你有没有发现，只要头一位是“1”的二进制数码，输出的一定是十进制的负数。那么这是怎么回事呢？

我们知道，计算机的运作原理，是以各个电子元器件电平（电压）高低来记录庞大数据的。高电平用“1”表示，低电平用“0”表示。而平常的加减法运算就会基于这样的工作机制。在计算整数加法时，它是严格按照0+0=0,0+1=1,1+0=1,1+1=10的规律执行的。诸如4+5=9（0100+0101=1001）这一类。但是我们在计算时一定会碰见负数或者减法。那么比进位操作要难一些的退位操作就会难以执行。如此我们要通过某种机制，来引入可以化减法为加法的负数表示形式。这样计算机的操作就会方便好多。

如何构建这种化减法为加法的机制呢？我们还是回到在小学就熟知的十进制退位减法。当所计算减法的位数不够的时候，我们会在被减数前一位的位置点一个小点，然后去做“10-x”的计算。点了点的那一位会减一，这就是“退位”。

那么，假设我们是初学者，刚刚接触了这一法则，开始算0-x,x可以是任意正整数。比如说0-1234，我们列竖式会变成这样：由于被减数任何一位都是0，所以我们从十位开始，会不断地点上小点，把这一位变成9。得到的结果便是，前面有无穷多个9，后面是8766。

这看似有点不符合常理。但是，假设我们规定，数字不得超过5位，且计算结果超出位数（到第六位）的部分删去不计，

那么0-1234会定义为98766。那么运算2345-1234时时我们会得出101111的结果。而数字不能超过6位，所以结果是1111。

我们再去看看所定义的数和原负数每一位的关系。

>个位数之和4+6=10=9+1，十位数之和3+6=9，百位数，千位数，万位数之和，均为9。

这就相当于在除了个位的每一位，负数为x，则对应定义的数为9-x，它们成互补关系。所以我们把所定义的新数不严谨地叫做“补码”。

再回到二进制。这个互补过程会简单的多。只要在首位添上“1”没有符号的二进制数把对应位x变为1-x（就是1变0,0变1），再把整个数字加上1，即为“补码”。

而且如果首位数字不带0，那么负数补码一定会比正数至少一位，所以不存在我们混淆正负数的情况。

最后举个负数补码换算的例子来加深印象。

>13（十进制）=1101（二进制）

>若规定负数补码码长为6，那么表示为001101.

>对所有数码进行变换，得结果110010.

>加一，得最终补码110011.

这样一来，我们便将-13转化为二进制数码“110011”.

我们现在来用补码计算24-13的值。

>24（十进制）=011000（二进制）

>24-13=24+(-13），转化为二进制就是011000+110011=1001011.

>多了一位，我们将首位“1”去掉，就是001011，即为11的二进制数码。

**IEEE754浮点数格式（共16bit，小数部分8bit）**

由于正负号占一位，小数部分占8位，故而指数部分占7位，即为Excess-63.

>±0.0,即为`* 0000000 00000000`

>±1.0,即为`* 0111111 00000000`

>±∞,即为`* 1111111 00000000`

>NaN,即为`* 1111111 nonzero`

>最大非规范化数，即为`* 0000000 11111111`

>最小非规范化数，即为`* 0000000 00000001`

>最大规范化浮点数即为`* 1111110 11111111`

>最小规范化浮点数即为`* 0000001 00000000` 
